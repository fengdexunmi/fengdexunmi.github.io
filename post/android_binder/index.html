<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta property="og:title" content="Android Binder通信过程" />
<meta property="og:description" content="Binder原理分析 参考资料  写给 Android 应用工程师的 Binder 原理剖析 Android 多进程、Binder 你必须知道的一切  1. 概念  线程：线程是CPU最小的调度单元，是有限的系统资源，也是处理任务的地方 进程：是一个执行单元，一般指设备上的一个程序或者一个应用 一个进程可以包含多个线程  2. 开启多线程 在AndroidManifest.xml文件配置process属性 - 以&rdquo;:&ldquo;指定进程名 - 完整的命名方式
android:process=&quot;:todo&quot; android:process=&quot;com.endselect.app.todo&quot;  3. 多进程问题 因为进程开启时Application都会重新创建，数据共享会变得不稳定，所以可能会出现以下问题：
 静态成员和单例模式失效 线程同步机制失效 SharePreference可靠性下降 Application会多次创建  4. 进程间的通信 Android中采用Binder机制进行进程间的通信。
序列化  Serializable Serializable序列的使用很简单，只需要在Java类实现Serializable接口，设置serialVersionUID即可 把对象转换为字节序列的过程称为对象的序列化 把字节序列恢复为对象的过程称为对象的反序列化 对象的序列化主要用途：  把对象的字节序列保存到文件中 在网络上传送对象的字节序列 发送网络请求就涉及到序列化和反序列化，发送方需要把对象转换为字节序列，接收方把字节序列恢复为Java对象   /** * 序列化Person对象 * * @throws IOException */ public static final void SerializablePerson() throws IOException { Person person = new Person(&quot;Frank&quot;, 20); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(new File(&quot;." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://www.newhandler.com/post/android_binder/" /><meta property="article:published_time" content="2019-01-19T18:27:26&#43;08:00"/>
<meta property="article:modified_time" content="2019-01-19T18:27:26&#43;08:00"/>

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Android Binder通信过程"/>
<meta name="twitter:description" content="Binder原理分析 参考资料  写给 Android 应用工程师的 Binder 原理剖析 Android 多进程、Binder 你必须知道的一切  1. 概念  线程：线程是CPU最小的调度单元，是有限的系统资源，也是处理任务的地方 进程：是一个执行单元，一般指设备上的一个程序或者一个应用 一个进程可以包含多个线程  2. 开启多线程 在AndroidManifest.xml文件配置process属性 - 以&rdquo;:&ldquo;指定进程名 - 完整的命名方式
android:process=&quot;:todo&quot; android:process=&quot;com.endselect.app.todo&quot;  3. 多进程问题 因为进程开启时Application都会重新创建，数据共享会变得不稳定，所以可能会出现以下问题：
 静态成员和单例模式失效 线程同步机制失效 SharePreference可靠性下降 Application会多次创建  4. 进程间的通信 Android中采用Binder机制进行进程间的通信。
序列化  Serializable Serializable序列的使用很简单，只需要在Java类实现Serializable接口，设置serialVersionUID即可 把对象转换为字节序列的过程称为对象的序列化 把字节序列恢复为对象的过程称为对象的反序列化 对象的序列化主要用途：  把对象的字节序列保存到文件中 在网络上传送对象的字节序列 发送网络请求就涉及到序列化和反序列化，发送方需要把对象转换为字节序列，接收方把字节序列恢复为Java对象   /** * 序列化Person对象 * * @throws IOException */ public static final void SerializablePerson() throws IOException { Person person = new Person(&quot;Frank&quot;, 20); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(new File(&quot;."/>



    <link rel="canonical" href="http://www.newhandler.com/post/android_binder/">

    <title>
      
        Android Binder通信过程 | New Handler
      
    </title>

    
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href="http://www.newhandler.comcss/style.css" rel="stylesheet">

    

    

    
  </head>
  <body>
    
      

<header class="blog-header">
    <nav class="navbar navbar-expand-md navbar-light bg-light">
        <a class="navbar-brand" href="/">
            <img src="/ic_launcher_round.png" width="30" height="30">
New Handler
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false"
            aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse justify-content-between" id="navbarNav">
            <ul class="navbar-nav">
                
                
            </ul>
            
        </div>
    </nav>
</header>

    

    
    <div class="container">
      <div class="row">
        <div class="col-12 col-lg-8 blog-main">

          

<header>
    <h2 class="blog-post-title">
    <a class="text-dark" href="/post/android_binder/">Android Binder通信过程</a>
</h2>

    


<div class="blog-post-date text-secondary">
    
        <time datetime="2019-01-19">Jan 19, 2019</time>
    
    
</div>

    
<div class="blog-post-tags text-secondary">
    <strong>Tags:</strong>
    
        <a class="badge badge-primary" href="/tags/android">Android</a>
    
        <a class="badge badge-primary" href="/tags/binder">Binder</a>
    
</div>

    
    <hr>
</header>
<article class="blog-post">
    

<h1 id="binder原理分析">Binder原理分析</h1>

<h2 id="参考资料">参考资料</h2>

<ul>
<li><a href="https://zhuanlan.zhihu.com/p/35519585"><strong>写给 Android 应用工程师的 Binder 原理剖析</strong></a></li>
<li><a href="https://blog.csdn.net/Alexwll/article/details/84894114"><strong>Android 多进程、Binder 你必须知道的一切</strong></a></li>
</ul>

<h2 id="1-概念">1. 概念</h2>

<ul>
<li>线程：线程是CPU最小的调度单元，是有限的系统资源，也是处理任务的地方</li>
<li>进程：是一个执行单元，一般指设备上的一个程序或者一个应用</li>
<li>一个进程可以包含多个线程</li>
</ul>

<h2 id="2-开启多线程">2. 开启多线程</h2>

<p>在AndroidManifest.xml文件配置process属性
- 以&rdquo;:&ldquo;指定进程名
- 完整的命名方式</p>

<pre><code class="language-Java">android:process=&quot;:todo&quot;
android:process=&quot;com.endselect.app.todo&quot;
</code></pre>

<h2 id="3-多进程问题">3. 多进程问题</h2>

<p>因为进程开启时Application都会重新创建，数据共享会变得不稳定，所以可能会出现以下问题：</p>

<ul>
<li>静态成员和单例模式失效</li>
<li>线程同步机制失效</li>
<li>SharePreference可靠性下降</li>
<li>Application会多次创建</li>
</ul>

<h2 id="4-进程间的通信">4. 进程间的通信</h2>

<p>Android中采用Binder机制进行进程间的通信。</p>

<h3 id="序列化">序列化</h3>

<ul>
<li>Serializable
Serializable序列的使用很简单，只需要在Java类实现Serializable接口，设置serialVersionUID即可
<strong>把对象转换为字节序列的过程称为对象的序列化</strong>
<strong>把字节序列恢复为对象的过程称为对象的反序列化</strong>
对象的序列化主要用途：

<ul>
<li>把对象的字节序列保存到文件中</li>
<li>在网络上传送对象的字节序列
发送网络请求就涉及到序列化和反序列化，发送方需要把对象转换为字节序列，接收方把字节序列恢复为Java对象</li>
</ul></li>
</ul>

<pre><code class="language-Java">    /**
     * 序列化Person对象
     *
     * @throws IOException
     */
    public static final void SerializablePerson() throws IOException {
        Person person = new Person(&quot;Frank&quot;, 20);
        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(new File(&quot;./Person.txt&quot;)));
        outputStream.writeObject(person);
        outputStream.close();
    }

    /**
     * 反序列化
     *
     * @return
     * @throws IOException
     * @throws ClassNotFoundException
     */
    public static final Person Deserializable() throws IOException, ClassNotFoundException {
        ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(new File(&quot;./Person.txt&quot;)));
        Person person = (Person) inputStream.readObject();
        inputStream.close();
        return person;
    }

    public static void main(String[] args) throws IOException, ClassNotFoundException {
        SerializablePerson();
        Person person = Deserializable();
        System.out.println(MessageFormat.format(&quot;name = {0}, age = {1}&quot;, person.getName(), person.getAge()));
    }
</code></pre>

<ul>
<li>Parcelable
Parcelable是在内存中进行序列化，更加高效</li>
</ul>

<p>Serializable开销大，需要大量的IO操作，Parcelable适用于Android，在内存中进行序列化。</p>

<h3 id="binder">Binder</h3>

<ul>
<li>Binder框架模型

<ul>
<li>Server: 服务的正在提供者，通过Binder驱动先向ServiceManger注册服务，驱动会为这个Binder创建位于内核中的实体和ServiceManger中的引用，并将名字和引用打包传给ServiceManager，ServiceManger将其填入查找表</li>
<li>Client: 服务的需求者和使用者，它向ServiceManger申请需要的服务</li>
<li>ServiceManger:</li>
<li>Binder驱动:</li>
</ul></li>
</ul>


    

    


</article>



        </div>

        <aside class="col-12 col-lg-3 ml-auto blog-sidebar">
    
        


<section>
    <h4>Recent Posts</h4>
    <ol class="list-unstyled">
        
        <li>
            <a href="/post/android_binder/">Android Binder通信过程</a>
        </li>
        
        <li>
            <a href="/post/first_article/">Android Handler源码分析</a>
        </li>
        
        <li>
            <a href="/post/">Posts</a>
        </li>
        
    </ol>
</section>

    
    
        <section>
    
        
    
        
        <h4>Tags</h4>
        <p>
            
            <a class="badge badge-primary" href="/tags/android">android</a>
            
            <a class="badge badge-primary" href="/tags/binder">binder</a>
            
            <a class="badge badge-primary" href="/tags/handler">handler</a>
            
        </p>
        
    
</section>
    
</aside>

      </div>
    </div>
    

    
      






<footer class="blog-footer w-100">
    <nav class="navbar navbar-light bg-light">
        <p class="w-100 text-center">Made with ❤ by <a href="https://github.com/fengdexunmi">NewHandler</a></p>
        <p class="w-100 text-center"><a href="#">Back to top</a></p>
    </nav>
</footer>

    

    
    
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
  </body>
</html>
